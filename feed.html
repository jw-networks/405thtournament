<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OBS Feed Slot</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:transparent; overflow:hidden; }
    iframe { width:100%; height:100%; border:0; }
  </style>
</head>
<body>
  <iframe id="vdo" allow="camera; microphone; autoplay; display-capture" src="about:blank"></iframe>

  <script>
    const EXPORT_CSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vRpG2Z5s4KvRw5iYM8AokvwxM6HEE5q1U2WWDOyOfyz3UBrAFnV80t7HVyK9iuA8SNxMS1bo0kj-e2Z/pub?gid=2053858318&single=true&output=csv";

    const params = new URLSearchParams(location.search);
    const slot = params.get("slot");      // "1".."8"
    const type = params.get("type");      // "cam" or "game"
    if (!slot || !type) throw new Error("Missing ?slot= and/or ?type=");

    function parseCsvKeyValue(text) {
      const lines = text.trim().split(/\r?\n/);
      const out = {};
      for (let i = 1; i < lines.length; i++) { // skip header
        const line = lines[i];
        const comma = line.indexOf(",");
        if (comma === -1) continue;
        const k = line.slice(0, comma).replace(/^"|"$/g, "").trim();
        const v = line.slice(comma + 1).replace(/^"|"$/g, "").trim();
        if (k) out[k] = v;
      }
      return out;
    }

    const ALLOW_ATTR = "camera; microphone; autoplay; display-capture";
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    async function hardSwapTo(url) {
      const old = document.getElementById("vdo");
      if (!old) return;

      try { old.src = "about:blank"; } catch (e) {}
      await sleep(50);

      const fresh = document.createElement("iframe");
      fresh.id = "vdo";
      fresh.allow = ALLOW_ATTR;
      fresh.style.width = "100%";
      fresh.style.height = "100%";
      fresh.style.border = "0";
      fresh.src = url;

      old.parentNode.replaceChild(fresh, old);
    }

    let lastBaseSrc = null;

    // --- NEW: prevent overlap / out-of-order swaps ---
    let inFlight = false;
    let requestSeq = 0;

    async function refresh() {
      if (inFlight) return;           // lock: only one refresh at a time
      inFlight = true;

      const mySeq = ++requestSeq;     // sequence id for this run

      try {
        const csvUrl = EXPORT_CSV_URL + (EXPORT_CSV_URL.includes("?") ? "&" : "?") + "t=" + Date.now();
        const res = await fetch(csvUrl, { cache: "no-store" });
        if (!res.ok) throw new Error("CSV fetch failed: " + res.status);

        const csv = await res.text();
        const kv = parseCsvKeyValue(csv);

        const key = `slot${slot}_${type}`;
        const raw = kv[key];

        // If the key is missing entirely, do nothing (prevents flicker to blank on bad reads)
        if (typeof raw === "undefined") return;

        const baseSrc = (raw || "about:blank").trim();

        // If a newer refresh started while we were waiting, ignore this result
        if (mySeq !== requestSeq) return;

        if (baseSrc !== lastBaseSrc) {
          lastBaseSrc = baseSrc;

          if (!baseSrc || baseSrc === "about:blank") {
            await hardSwapTo("about:blank");
          } else {
            const busted = baseSrc + (baseSrc.includes("?") ? "&" : "?") + "_r=" + Date.now();
            await hardSwapTo(busted);
          }
        }
      } catch (e) {
        // swallow errors so we don't “blank-flip” on transient fetch issues
        // (OBS console will still show the error if you open DevTools)
        // console.error(e);
      } finally {
        inFlight = false;
      }
    }

    refresh();
    setInterval(refresh, 750);
  </script>
</body>
</html>
